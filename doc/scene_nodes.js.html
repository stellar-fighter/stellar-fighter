<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: scene_nodes.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: scene_nodes.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * A super SceneNode class that defines scene
 */
class SceneNode {
  /**
   * Create a new SceneNode object
   * @param {Object} transform - not implemented yet
   * @param {Object} pos - The Vector object for entity's pos
   * @param {Object} size - The Vector object for entity's size
   * @param {Object[]} children - The array of childeren SceneNode object
   * @param {Object} render - The render method for this object
   */
  constructor({transform, pos, size, children, render}) {
    this.transform = transform; // not implemented yet
    this.pos = pos || null;
    this.size = size || null;
    this.render = render || SceneNode.defaultRender;
    this.children = children || [];
    this.alive = true;
  }
  get alive() {
    if(this._alive === undefined)
      return true;
    return this._alive;
  }
  set alive(alive) {
    if(this._alive === undefined || this._alive == true)
      this._alive = alive;
  }
  addChild(child) {
    this.children.push(child);
  }
  /**
  * Render all SceneNode object in children array
   * @param {Object} canvas - The main canvas to show visual part in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  renderAll({canvas, ctx, camera}) {
    this.render({self: this, canvas, ctx, camera});
    const newChildren = [];
    for(let child of this.children) {
      if(child.alive) {
        newChildren.push(child);
        child.renderAll({canvas, ctx, camera});
      }
    }
    this.children = newChildren;
  }
  /**
  * Render as SceneNode class default rendering
   * @param {Object} self - The SceneNode object itself
   * @param {Object} canvas - The main canvas to show visual part in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  static defaultRender({self, canvas, ctx, camera}) {
    const {pos, size} = self;
    if(!(ctx &amp;&amp; camera &amp;&amp; pos &amp;&amp; size))
      return;
    ctx.save();
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.rect(
      camera.toRealX(pos.x),
      camera.toRealY(pos.y),
      size.x,
      size.y
    );
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }
}

/**
 * A SceneNode related to entity's visibility
 * @extends SceneNode
 */
class Sprite extends SceneNode {
  /**
   * Create a new Sprite object
   * @param {Object} pos - The Vector object for entity's pos
   * @param {Object} size - The Vector object for entity's size
   * @param {Object[]} children - The array of childeren SceneNode object
   * @param {function} render - The render method for this object
   * @param {Image} texture - The texture image of entity
   */
  constructor({pos, size, children, render, texture}) {
    super({
      pos, size, children,
      render: (render || Sprite.defaultRender)
    });
    if(texture === undefined)
      throw new Error('RequiredParam');
    this.texture = texture;
  }
  /**
  * Render as Sprite class default rendering
   * @param {Object} self - The Sprite object itself
   * @param {Object} canvas - The main canvas to show visual part in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  static defaultRender({self, canvas, ctx, camera}) {
    const {pos, size, texture} = self;
    if(!(ctx &amp;&amp; camera &amp;&amp; pos &amp;&amp; size))
      return;
    ctx.save();
    ctx.drawImage(
      texture,
      camera.toRealX(pos.x),
      camera.toRealY(pos.y),
      camera.toRealW(size.x),
      camera.toRealH(size.y)
    );
    ctx.strokeStyle = 'red';
    ctx.strokeRect(
      camera.toRealX(pos.x),
      camera.toRealY(pos.y),
      camera.toRealW(size.x),
      camera.toRealH(size.y)
    );
    ctx.restore();
  }
}

/**
 * A SceneNode related to game's background
 * @extends SceneNode
 */
class Background extends SceneNode {
  /**
   * Create a new Background object
   * @param {Object[]} children - The array of childeren SceneNode object
   * @param {Image} texture - The texture image of background
   */
  constructor({children, texture}) {
    super({
      children,
      render: (Background.defaultRender)
    });
    if(texture === undefined)
      throw new Error('RequiredParam');
    this.texture = texture;
  }
  /**
  * Render as Background class default rendering
   * @param {Object} self - The Background object itself
   * @param {Object} canvas - The main canvas to show background in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  static defaultRender({self, canvas, ctx, camera}) {
    const {texture} = self;
    if(!(ctx &amp;&amp; camera))
      return;
    ctx.save();
    ctx.drawImage(this.texture, camera.toRealX(0), camera.toRealY(Math.floor(Math.abs(camera.pos.y) / camera.absH) * -camera.absH), camera.realW, camera.realH); // TODO: remove hardcoded numbers
    ctx.drawImage(this.texture, camera.toRealX(0), camera.toRealY((Math.floor(Math.abs(camera.pos.y) / camera.absH) + 1) * -camera.absH), camera.realW, camera.realH);
    ctx.restore();
  }
}

/**
 * A SceneNode related to displaying current score
 * @extends SceneNode
 */
class ScoreDisplay extends SceneNode {
  /**
   * Create a new Background object
   * @param {Object} state - The state object related to current game
   */
  constructor({state}) {
    super({
      render: (ScoreDisplay.defaultRender)
    });
    this.state = state;
  }
  /**
  * Render as ScoreDisplay class default rendering
   * @param {Object} self - The ScoreDisplay object itself
   * @param {Object} canvas - The main canvas to show score in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  static defaultRender({self, canvas, ctx, camera}) {
    const {texture} = self;
    if(!ctx)
      return;
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '' + (150 * camera.xScale) + 'px Arial';
    ctx.fillText(this.state.score, 100 * camera.xScale, 200 * camera.yScale);
  }
}

/**
 * A SceneNode related to displaying current HP of entity
 * @extends SceneNode
 */
class HpDisplay extends SceneNode {
  /**
   * Create a new Sprite object
   * @param {Object} pos - The Vector object for entity's pos
   * @param {Object} size - The Vector object for entity's size
   * @param {Object[]} children - The array of childeren SceneNode object
   * @param {int} hp - The hp of entity
   */
  constructor({pos, size, children, hp}) {
    super({
      pos, size, children,
      render: HpDisplay.defaultRender
    });
    if(hp === undefined)
      throw new Error('RequiredParam');
    this.hp = hp;
  }
  /**
  * Render as HpDisplay class default rendering
   * @param {Object} self - The HpDisplay object itself
   * @param {Object} canvas - The main canvas to show HP in game
   * @param {Object} ctx - The 2D context of main canvas
   * @param {Object} camera - The Camera object of main canvas
  */
  static defaultRender({self, canvas, ctx, camera}) {
    const {pos, size, hp} = self;
    if(!(canvas &amp;&amp; ctx &amp;&amp; camera &amp;&amp; pos &amp;&amp; size &amp;&amp; hp))
      return;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#00FF00';
    ctx.font = camera.toRealW(100) + 'px Arial';
    ctx.fillText(
      hp.val,
      camera.toRealX(pos.vec.x),
      camera.toRealY(pos.vec.y)
    );
    ctx.closePath();
    ctx.restore();
  }
}

export {SceneNode, Sprite, Background, HpDisplay, ScoreDisplay};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Background.html">Background</a></li><li><a href="CamOutComp.html">CamOutComp</a></li><li><a href="CollComp.html">CollComp</a></li><li><a href="CollSystem.html">CollSystem</a></li><li><a href="Comp.html">Comp</a></li><li><a href="CtrlComp.html">CtrlComp</a></li><li><a href="HpComp.html">HpComp</a></li><li><a href="HpDisplay.html">HpDisplay</a></li><li><a href="MovComp.html">MovComp</a></li><li><a href="MovSystem.html">MovSystem</a></li><li><a href="PosComp.html">PosComp</a></li><li><a href="SceneNode.html">SceneNode</a></li><li><a href="ScoreComp.html">ScoreComp</a></li><li><a href="ScoreDisplay.html">ScoreDisplay</a></li><li><a href="ShootingComp.html">ShootingComp</a></li><li><a href="SizeComp.html">SizeComp</a></li><li><a href="Sprite.html">Sprite</a></li><li><a href="System.html">System</a></li><li><a href="TeamComp.html">TeamComp</a></li><li><a href="Timer.html">Timer</a></li><li><a href="VisComp.html">VisComp</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Fri Jun 07 2019 03:54:07 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
